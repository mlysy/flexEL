% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qr_evalG.R
\name{qr_evalG}
\alias{qr_evalG}
\title{Evaluate the G matrix for a quantile regression model.}
\usage{
qr_evalG(y, X, alpha, Beta, sp = NULL)
}
\arguments{
\item{y}{A numeric vector of resoponses of length \code{n_obs} where \code{n_obs}
is the number of observations.}

\item{X}{A numeric matrix of covariates of dimension \code{n_obs} x \code{n_bet}
where \code{n_obs} is the number of observations and \code{n_bet} is the number
of coefficients (length of \code{beta}). \code{X} should contain a column of \code{1}s
explicitly and the corresponding element of \code{beta} (a column of \code{Beta})
corresponds to the quantile value of \code{eps} at that quantile level.}

\item{alpha}{A numeric vector of quantile levels of length \code{n_qts}.}

\item{Beta}{A numeric matrix of dimension \code{n_bet} x \code{n_qts}, each
column corresponds to the parameters at the specific quantile levels.}

\item{sp}{A positive scalar as the smoothing parameter. If \code{s = NULL}, then no smoothing is performed.}
}
\value{
A numeric matrix of dimension \code{n_obs} x (\code{n_bet} x \code{n_qts}).
}
\description{
Evaluate the G matrix for a quantile regression model.
}
\details{
Assuming data were generated from

\if{html}{\out{<div class="sourceCode">}}\preformatted{y_i = x_i'beta + eps_i, for i = 1, ..., n,
}\if{html}{\out{</div>}}

where \code{eps_i}'s are ~iid \code{eps}, with \code{E[eps] = 0} and \code{Var[eps] = 1}.
Quantile regression estimates the alpha-level quantile of the response variable, i.e.,

\if{html}{\out{<div class="sourceCode">}}\preformatted{Q_alpha(y | x_i) = x_i'beta, for i = 1, ..., n.
}\if{html}{\out{</div>}}

where the 1st element of \code{x_i} should be 1 and  the 1st element of \code{beta} corresponds
to the \code{alpha}-level quantile of \code{eps}.
The estimating equation can be derived based on the minimizing "check function" introduced by
Koenker and Bassett (1978),

\if{html}{\out{<div class="sourceCode">}}\preformatted{rho_alpha(u) = u * (alpha - 1\{u <= 0\})
}\if{html}{\out{</div>}}

where \code{alpha} is the quantile level, \verb{1\{\}} is the indicator function which returns 1 if the
condition is true and 0 otherwise, and \verb{u_i = y_i - x_i'beta}. That is,

\if{html}{\out{<div class="sourceCode">}}\preformatted{min_beta rho(y - X*beta)
}\if{html}{\out{</div>}}

The above minimization problem is equivalent to setting it's first derivative
w.r.t \code{beta} to 0, i.e.,

\if{html}{\out{<div class="sourceCode">}}\preformatted{phi(y - X*beta) = 0
}\if{html}{\out{</div>}}

where \code{phi} is the first derivative of \code{rho}.
The left-hand-side of the above equation is the \code{G} matrix returned by this function.
}
\examples{
## simulate some data ##
n <- 20
p <- 2
X <- replicate(p-1, rnorm(n))
X <- cbind(1, X)
beta0 <- c(1, 2)
y <- c(X \%*\% beta0) + rnorm(n)

## calculate G matrix given data and certain parameter values ##
# a single quantile level (with continuity correction)
alpha <- 0.5
beta <- c(1, 2)
qr_evalG(y, X, alpha, beta, s = 1)

# multiple quantile levels (with continuity correction)
alpha <- c(0.25, 0.75)
Beta <- cbind(c(0.5, 2), c(1.5, 2)) # each column corresponds to one quantile level
qr_evalG(y, X, alpha, Beta, s = 1)
}
\references{
G. Basset and R. Koenker. Regression quantiles. Econometrica, 46(1):33â€“50, 1978.
}
