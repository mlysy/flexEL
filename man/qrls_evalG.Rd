% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qrls_evalG.R
\name{qrls_evalG}
\alias{qrls_evalG}
\title{Evaluate the G matrix for a location-scale quantile regression model.}
\usage{
qrls_evalG(y, X, Z, alpha, Beta, Gamma, Sig2, Nu, sp = 0)
}
\arguments{
\item{y}{Length-\code{nObs} vector of responses.}

\item{X}{\code{nObs x nBet} matrix of covariates in the location function, where \code{nObs} is the number of observations and \code{nBet} is the dimension of coefficients in the location function.}

\item{Z}{\code{nObs x nGam} matrix of covariates in the scale function, where \code{nObs} is the number of observations and \code{nGam} is the dimension of coefficients in the scale function.}

\item{alpha}{A length-\code{n_qts} numeric vector of quantile levels.}

\item{Beta}{An \verb{n_bet x n_qts} matrix, each column is a vector of coefficients in location function.}

\item{Gamma}{An \verb{n_gam x n_qts} matrix, each column is a vector of coefficients in scale function.}

\item{Sig2}{A positive scalar whose square root is the scale parameter for the error term.}

\item{Nu}{A length-\code{n_qts} numeric vector of quantile values corresponding to each alpha.}

\item{sp}{A positive scalar as smoothing parameter.}
}
\value{
G matrix of size `for location-scale quantile regression model.
}
\description{
Evaluate the G matrix for a location-scale quantile regression model.
}
\details{
Assuming data were generated from\preformatted{y_i = x_i'beta + sigma * exp(z_i'gamma) * eps_i, for i = 1, ..., n,
}

where \code{eps_i}'s are ~iid \code{eps}, with \code{E[eps] = 0} and \code{Var[eps] = 1}.
Quantile regression estimates the alpha-level quantile of the response variable, i.e.,\preformatted{Q_alpha(y | x_i, z_i) = x_i'beta + sigma * exp(z_i'gamma) * nu_alpha,
for i = 1, ..., n.
}

where \code{nu_alpha} is the alpha-level quantile value of \code{eps}.
Neither \code{x_i} nor \code{z_i} should have a constant term.
}
\examples{
n <- 20
p <- 5
q <- 3
X <- replicate(p, rnorm(n))
Z <- replicate(q, rnorm(n))
alpha <- runif(1)
beta <- rnorm(p)
gamma <- rnorm(q)
nu <- rnorm(1)
sig2 <- 1.5
y <- c(X \%*\% beta + sqrt(sig2)*exp(Z \%*\% gamma)*rnorm(n)) # with multiplicative N(0,1) error

# no continuity correction
qrls_evalG(y, X, Z, alpha, beta, gamma, sig2, nu)

# with continuity correction
sp <- 10
qrls_evalG(y, X, Z, alpha, beta, gamma, sig2, nu, sp)
}
